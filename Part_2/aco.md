ANT COLONY OPTIMIZATION

ΣΗΜΕΙΩΣΗ: Ακολουθησα το paper κατα γραμμα και στην αρχη της σελιδας 7 ελεγε οτι επιλογη επομενου feasible σημειου προς εισαγωγη γινεται τυχαια, ενω η εξισωση του 
ant colony χρησιμοποιειται μονο για την επιλογη ορατης ακμης απ τις υποψηφιες (που να μπει το καινουριο σημειο). Αυτο βγαζει περισσοτερο νοημα για να μην ειναι
υπερβολικα μεγαλος ο χωρος των λυσεων αλλα στην εκφωνηση της ασκησης ελεγε κατι λιγο διαφορετικο.

Για να λυσω το προβλημα οριζω στο utils_aco.hpp καινουρια κλαση Edge που ειναι μια ακμη στο χωρο των μερικων λυσεων (πχ ενωνει ενα πιθανο τριγωνο με feasible τετραγωο)
και κλαση Ant που ειναι ενα μυρμηγκι που περπατει πανω σις ακμες και κατασκευαζει λυση. Μια ακμη αποθηκευει heuristic value και pheromone value καθως και τα πολυγωνα 
στα ακρα της (source και target). Oι υλοποιησεις ολων των συναρτησεων βρισκονται στo utils_aco.cpp.

Oλες οι συναρτησεις οι οποιες ειναι και πολυ καλα σχολιασμενες: 

Edge constructor: Aρχικοποιει καταλληλα ενα edge, μπορειτε να αλλαξετε την αρχικη τιμη φερομονης σε οτι θελετε.

Overloaded operator == για ακμες: Το χρειαζεται η συναρτηση std::find για να βρισκει "ιδιες" ακμες, δηλαδη που εχουμε ξαναεπισκεφθει.

Edge::update_pheromone: Δεχεται ως ορισμα το ρο και ολα τα μυρμηγκια για να δει ποιες ακμες επισκεφθηκαν, κι αν βρει τον εαυτο της αυξανει το Δ. Αλλαζει τη φερομονη
τηε βασει της σχετικης εξισωσης.

Overloaded operator < για μυρμηγκια: Το χρειαζεται η συναρτηση std::max_element για να βρει την καλυτερη λυση. Τα μυρμμηγκια συγκρινονται με βαση το evaluation της 
λυσης τους.

Ant::evaluate_solution: Αξιολογει τη λυση ενος μυρμηγκιου αναλογα με το αν εχουμε παραμετρο max η min.

feasible_insertion: Ειναι το αντιστοιχο του να ελεγχω αν μια ακμη πολυγωνου ειναι ορατη απο ενα σημειο, αλλα αυτη δοκιμαζει την εισαγωγη σε ενα index και επιστρεφει
true αν το πολυγωνο που φτιαχτηκε ειναι απλο. Θα μπορουσα να βαλω τη συναρτηση is_visible που εχω φτιαξει ετσι κι αλλιως για την πρωτη εργασια αλλα αυτος ο τροπος 
φαινεται λιγο πιο αποδοτικος.

is_feasible: Ελεγχει αν ενα σημειο ειναι feasible ως προς το πολυγωνο, με δυο κριτηρια. Πρεπει ολα απ τα σημεια που περισσευουν να ΜΗΝ ειναι στο εσωτερικο convex hull 
του (polygon U new_point). Kαι επισης να υπαρχει τουλαχιστον ενα feasible insertion για το σημειο (ορατη ακμη).

select_edge: Επιλεγει μια ακμη απο τις υποψηφιες με βαση την εξισωση πιθανοτητας του ant colony την επιστρεφει ως εξης. Κανει παραγωγη τυχαιου αριθμου απο 0 ως 1 και 
αναλογα σε ποιο range θα πεσει, επιστρεφει και αλλη ακμη. Πχ μια ακμη με πιθανοτητα 0.1 μπορει να ειναι στο rnge 0.4 - 0.5.

Ant::build_solution: Χρειαζεται ως ορισμα τις ακμες edges για να δει ποιες εχουν ξαναεπισκεθφει στο παρελθον. Το μυρμηγκι χτιζει τη λυση ως εξης. Βρικει ολα τα feasible
σημεια και επιλεγει ενα τυχαια. Επειτα βρισκει ολες τις feasible insertions και τις αποθηκευει ως υποψηφιες ακμες. Αν συναντησει καποια ακμη που εχει ξαναεπισκεφθει
κραταει εκεινη και οχι αυτη που μολις δημιουργηθηκε. Εχοντας ολες τις υποψηφιες ακμες, επιλεγει μια και συμεχιζει τη διαδικασια μεχρι να μην μεινουν καινουρια σημεια.

update_trails: Κανει update τη φερομονη για καθε ακμη που ανηκει στα trails των μυρμηγκιων. Aν υπαρχει ελιτισμος, λαμβανουμε υποψη μονο το μονοπατι του καλυτερου
μυρμηγκιου για να δουμε ποιες ακμες θα ενισχηθουν, αλλιως ολα.

Στο aco.cpp βρισκεται ο αλγοριθμος ο οποιος αρχικοποιει τυχαια ενα τριγωνο και επειτα ακολουθει τον αλγοριμο των διαφανειων για L κυκλους και K μυρμηγκια οπου 
Κ = points.size()/4 + 1 (Μπορειτε να το αλλαξετε). Καθε μυρμηγκι χτιζει τη λυση του, την κανει evaluate και επιλεγεται το καλυτερο μυρμηγκι σε καθε κυκλο. Στο τελος
επιστρεφει το καλυτερο πολυγωνο απ ολους τους κυκλους.
